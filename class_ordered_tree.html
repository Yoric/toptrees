<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Tree Compression with Top Trees Revisited: OrderedTree&lt; NodeType, EdgeType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tree Compression with Top Trees Revisited
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_ordered_tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OrderedTree&lt; NodeType, EdgeType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Ordered tree data structure.  
 <a href="class_ordered_tree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for OrderedTree&lt; NodeType, EdgeType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="class_ordered_tree__coll__graph.png" border="0" usemap="#_ordered_tree_3_01_node_type_00_01_edge_type_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="_ordered_tree_3_01_node_type_00_01_edge_type_01_4_coll__map" id="_ordered_tree_3_01_node_type_00_01_edge_type_01_4_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a00fd2d8abe3d806359f64418f554b292"><td class="memItemLeft" align="right" valign="top">typedef NodeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a00fd2d8abe3d806359f64418f554b292">nodeType</a></td></tr>
<tr class="memdesc:a00fd2d8abe3d806359f64418f554b292"><td class="mdescLeft">&#160;</td><td class="mdescRight">the node type used in this tree  <a href="#a00fd2d8abe3d806359f64418f554b292">More...</a><br /></td></tr>
<tr class="separator:a00fd2d8abe3d806359f64418f554b292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e706c8a83af2371285fd9c26fc061c9"><td class="memItemLeft" align="right" valign="top">typedef EdgeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a9e706c8a83af2371285fd9c26fc061c9">edgeType</a></td></tr>
<tr class="memdesc:a9e706c8a83af2371285fd9c26fc061c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of the edges used in this tree  <a href="#a9e706c8a83af2371285fd9c26fc061c9">More...</a><br /></td></tr>
<tr class="separator:a9e706c8a83af2371285fd9c26fc061c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2d87bce2fd7297372d8eeaeaf58c99db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a2d87bce2fd7297372d8eeaeaf58c99db">OrderedTree</a> (const int n=0, const int m=0)</td></tr>
<tr class="separator:a2d87bce2fd7297372d8eeaeaf58c99db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ba3358b30a489b54baf3296a0b7464"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a40ba3358b30a489b54baf3296a0b7464">OrderedTree</a> (const <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt; &amp;other)</td></tr>
<tr class="separator:a40ba3358b30a489b54baf3296a0b7464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1f92336e213a365dcce5aaa9bde4bf"><td class="memItemLeft" align="right" valign="top">EdgeType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a5b1f92336e213a365dcce5aaa9bde4bf">firstEdge</a> ()</td></tr>
<tr class="memdesc:a5b1f92336e213a365dcce5aaa9bde4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the dummy edge  <a href="#a5b1f92336e213a365dcce5aaa9bde4bf">More...</a><br /></td></tr>
<tr class="separator:a5b1f92336e213a365dcce5aaa9bde4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c98c73a9f80543ebcbc78dd0a0858f"><td class="memItemLeft" align="right" valign="top">EdgeType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a14c98c73a9f80543ebcbc78dd0a0858f">firstEdge</a> (const int u)</td></tr>
<tr class="separator:a14c98c73a9f80543ebcbc78dd0a0858f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505076774887ba7391c2d3295c0c74c8"><td class="memItemLeft" align="right" valign="top">const EdgeType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a505076774887ba7391c2d3295c0c74c8">firstEdge</a> (const int u) const </td></tr>
<tr class="separator:a505076774887ba7391c2d3295c0c74c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82a5cc65f5748cd93881d3976f40c6a"><td class="memItemLeft" align="right" valign="top">EdgeType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#ab82a5cc65f5748cd93881d3976f40c6a">lastEdge</a> ()</td></tr>
<tr class="memdesc:ab82a5cc65f5748cd93881d3976f40c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the last edge  <a href="#ab82a5cc65f5748cd93881d3976f40c6a">More...</a><br /></td></tr>
<tr class="separator:ab82a5cc65f5748cd93881d3976f40c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1ab88ae092a8b2cf145a5ba57e4971"><td class="memItemLeft" align="right" valign="top">EdgeType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#aec1ab88ae092a8b2cf145a5ba57e4971">lastEdge</a> (const int u)</td></tr>
<tr class="separator:aec1ab88ae092a8b2cf145a5ba57e4971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee1e8524bf710357b6f7d68fa64dcd0"><td class="memItemLeft" align="right" valign="top">const EdgeType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a7ee1e8524bf710357b6f7d68fa64dcd0">lastEdge</a> (const int u) const </td></tr>
<tr class="separator:a7ee1e8524bf710357b6f7d68fa64dcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b7882fe155507f941a32691d63fb89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a87b7882fe155507f941a32691d63fb89">nodeId</a> (const NodeType *node)</td></tr>
<tr class="separator:a87b7882fe155507f941a32691d63fb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08cc116060aceed72652e875d96ff6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#af08cc116060aceed72652e875d96ff6a">edgeId</a> (const EdgeType *edge)</td></tr>
<tr class="separator:af08cc116060aceed72652e875d96ff6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7963d8d12b4fb649977d083c049be9f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a7963d8d12b4fb649977d083c049be9f4">addNode</a> ()</td></tr>
<tr class="separator:a7963d8d12b4fb649977d083c049be9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8fe28f1efab626e18370a1ac4e793a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a9d8fe28f1efab626e18370a1ac4e793a">addNodes</a> (const int n)</td></tr>
<tr class="separator:a9d8fe28f1efab626e18370a1ac4e793a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d29122eb44dbe6b7f000d48f502703"><td class="memItemLeft" align="right" valign="top">EdgeType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a20d29122eb44dbe6b7f000d48f502703">addEdge</a> (const int from, const int to, const int extraSpace=0)</td></tr>
<tr class="separator:a20d29122eb44dbe6b7f000d48f502703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70116d7ed7b45575d67054cb9b849b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#ab70116d7ed7b45575d67054cb9b849b1">killNodes</a> ()</td></tr>
<tr class="separator:ab70116d7ed7b45575d67054cb9b849b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61a2fbe7bec02c6257708d8f1134dec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#aa61a2fbe7bec02c6257708d8f1134dec">removeEdge</a> (const int from, const int edge, const bool <a class="el" href="class_ordered_tree.html#a912ed15169fea16a72df1295f86eb2fd">compact</a>=true)</td></tr>
<tr class="separator:aa61a2fbe7bec02c6257708d8f1134dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf4aebe1125902df0a748f29eaba990"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#addf4aebe1125902df0a748f29eaba990">removeEdgeTo</a> (const int from, const int to, const bool <a class="el" href="class_ordered_tree.html#a912ed15169fea16a72df1295f86eb2fd">compact</a>=true)</td></tr>
<tr class="separator:addf4aebe1125902df0a748f29eaba990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23287252e8acca79a59ee7453abca69a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a23287252e8acca79a59ee7453abca69a">mergeSiblings</a> (const EdgeType *leftEdge, const EdgeType *rightEdge, int &amp;newNode, <a class="el" href="_common_8h.html#a97009d0c192b99b1a98c91001b6bb932">MergeType</a> &amp;mergeType)</td></tr>
<tr class="separator:a23287252e8acca79a59ee7453abca69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55db4b702c12893c28a7f73b50ee768f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a55db4b702c12893c28a7f73b50ee768f">mergeChain</a> (const int middleId, <a class="el" href="_common_8h.html#a97009d0c192b99b1a98c91001b6bb932">MergeType</a> &amp;mergeType)</td></tr>
<tr class="separator:a55db4b702c12893c28a7f73b50ee768f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0a4924cb945b7b376b3a5cc58d98a9"><td class="memTemplParams" colspan="2">template&lt;typename LabelType &gt; </td></tr>
<tr class="memitem:aca0a4924cb945b7b376b3a5cc58d98a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#aca0a4924cb945b7b376b3a5cc58d98a9">isEqual</a> (const <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt; &amp;other, LabelType &amp;labels, LabelType &amp;otherLabels, const bool verbose=false) const </td></tr>
<tr class="separator:aca0a4924cb945b7b376b3a5cc58d98a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a8a0a7a547f33ada52e4d4d86328fb"><td class="memTemplParams" colspan="2">template&lt;typename LabelType &gt; </td></tr>
<tr class="memitem:a43a8a0a7a547f33ada52e4d4d86328fb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a43a8a0a7a547f33ada52e4d4d86328fb">nodesEqual</a> (const <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt; &amp;other, LabelType &amp;labels, LabelType &amp;otherLabels, const int <a class="el" href="class_ordered_tree.html#a87b7882fe155507f941a32691d63fb89">nodeId</a>, const int otherNodeId, const bool verbose=false) const </td></tr>
<tr class="memdesc:a43a8a0a7a547f33ada52e4d4d86328fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive node comparison helper function used by <a class="el" href="class_ordered_tree.html#aca0a4924cb945b7b376b3a5cc58d98a9">isEqual()</a>. You should not need to use this directly.  <a href="#a43a8a0a7a547f33ada52e4d4d86328fb">More...</a><br /></td></tr>
<tr class="separator:a43a8a0a7a547f33ada52e4d4d86328fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0b8ba32873925ccc8dbb319f6fbf45"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#aff0b8ba32873925ccc8dbb319f6fbf45">summary</a> () const </td></tr>
<tr class="memdesc:aff0b8ba32873925ccc8dbb319f6fbf45"><td class="mdescLeft">&#160;</td><td class="mdescRight">A one-line summary of the tree.  <a href="#aff0b8ba32873925ccc8dbb319f6fbf45">More...</a><br /></td></tr>
<tr class="separator:aff0b8ba32873925ccc8dbb319f6fbf45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29695aaf8b1705665b786b6d10e06d24"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a29695aaf8b1705665b786b6d10e06d24">shortString</a> () const </td></tr>
<tr class="separator:a29695aaf8b1705665b786b6d10e06d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7a54309a9226726cdbadb4d7c201f8"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#aee7a54309a9226726cdbadb4d7c201f8">toString</a> () const </td></tr>
<tr class="memdesc:aee7a54309a9226726cdbadb4d7c201f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">String representation of the tree, including all nodes and edges.  <a href="#aee7a54309a9226726cdbadb4d7c201f8">More...</a><br /></td></tr>
<tr class="separator:aee7a54309a9226726cdbadb4d7c201f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af283a4e3e05aa60a6ffa74efcdfab76c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#af283a4e3e05aa60a6ffa74efcdfab76c">checkConsistency</a> ()</td></tr>
<tr class="separator:af283a4e3e05aa60a6ffa74efcdfab76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912ed15169fea16a72df1295f86eb2fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a912ed15169fea16a72df1295f86eb2fd">compact</a> (const bool verbose=true, const int factor=1)</td></tr>
<tr class="separator:a912ed15169fea16a72df1295f86eb2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34b42496a697f8d9b25e2a28e56f172"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#ad34b42496a697f8d9b25e2a28e56f172">compactNode</a> (const int <a class="el" href="class_ordered_tree.html#a87b7882fe155507f941a32691d63fb89">nodeId</a>)</td></tr>
<tr class="separator:ad34b42496a697f8d9b25e2a28e56f172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7d966f7e234de6bf950e21b0878b0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a4a7d966f7e234de6bf950e21b0878b0a">inplaceCompact</a> (const bool verbose=true)</td></tr>
<tr class="separator:a4a7d966f7e234de6bf950e21b0878b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d892bca85235b29ff2c6ce1ec5596c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a3d892bca85235b29ff2c6ce1ec5596c2">inplaceCompact</a> (std::vector&lt; bool &gt; &amp;dirty, const bool verbose=true)</td></tr>
<tr class="separator:a3d892bca85235b29ff2c6ce1ec5596c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7633cfabb942e9c6dd3f95a6533f1c07"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Fold , typename Callback &gt; </td></tr>
<tr class="memitem:a7633cfabb942e9c6dd3f95a6533f1c07"><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a7633cfabb942e9c6dd3f95a6533f1c07">foldLeftPostOrder</a> (const Callback &amp;callback, const Fold &amp;fold, const T initial) const </td></tr>
<tr class="separator:a7633cfabb942e9c6dd3f95a6533f1c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ba00857ecf979a8e64226722579a98"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Fold , typename Callback &gt; </td></tr>
<tr class="memitem:a73ba00857ecf979a8e64226722579a98"><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a73ba00857ecf979a8e64226722579a98">traverseFoldLeftPostOrder</a> (const int <a class="el" href="class_ordered_tree.html#a87b7882fe155507f941a32691d63fb89">nodeId</a>, const Callback &amp;callback, const Fold &amp;fold, const T initial) const </td></tr>
<tr class="memdesc:a73ba00857ecf979a8e64226722579a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">This does the work for <a class="el" href="class_ordered_tree.html#a7633cfabb942e9c6dd3f95a6533f1c07">foldLeftPostOrder()</a> and should not be used directly.  <a href="#a73ba00857ecf979a8e64226722579a98">More...</a><br /></td></tr>
<tr class="separator:a73ba00857ecf979a8e64226722579a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b9a851ac3450550c512ea75ea2ff62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a68b9a851ac3450550c512ea75ea2ff62">height</a> () const </td></tr>
<tr class="separator:a68b9a851ac3450550c512ea75ea2ff62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56356437f508f5cff5bb5447f0539f90"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a56356437f508f5cff5bb5447f0539f90">avgDepth</a> () const </td></tr>
<tr class="separator:a56356437f508f5cff5bb5447f0539f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caa558a929a55e87e3c614d0707661c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a3caa558a929a55e87e3c614d0707661c">clear</a> ()</td></tr>
<tr class="separator:a3caa558a929a55e87e3c614d0707661c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a269149ab46051dbd0d5cf8325ed1fcb9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; NodeType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a269149ab46051dbd0d5cf8325ed1fcb9">nodes</a></td></tr>
<tr class="separator:a269149ab46051dbd0d5cf8325ed1fcb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d83eedb11688aeac05e4f5b8070d15"><td class="memItemLeft" align="right" valign="top">std::vector&lt; EdgeType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a76d83eedb11688aeac05e4f5b8070d15">edges</a></td></tr>
<tr class="separator:a76d83eedb11688aeac05e4f5b8070d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95203be7b453854a72f62df96ad45f2b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a95203be7b453854a72f62df96ad45f2b">_firstFreeNode</a></td></tr>
<tr class="separator:a95203be7b453854a72f62df96ad45f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cee9c6807d3f23acc2df9776e419ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a31cee9c6807d3f23acc2df9776e419ea">_firstFreeEdge</a></td></tr>
<tr class="separator:a31cee9c6807d3f23acc2df9776e419ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cec5b4d74adf59b17530e7dfe9a7cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#ae8cec5b4d74adf59b17530e7dfe9a7cb">_numNodes</a></td></tr>
<tr class="separator:ae8cec5b4d74adf59b17530e7dfe9a7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8faf8ec27c5ad1c8289bc1203ee89fba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a8faf8ec27c5ad1c8289bc1203ee89fba">_numEdges</a></td></tr>
<tr class="separator:a8faf8ec27c5ad1c8289bc1203ee89fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a209920ce1aafd5cf5c0e2011c90d85f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#a209920ce1aafd5cf5c0e2011c90d85f9">initialise</a> (const int n, const int m)</td></tr>
<tr class="separator:a209920ce1aafd5cf5c0e2011c90d85f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8f425f70fa557c11c1d740139d203a"><td class="memItemLeft" align="right" valign="top">EdgeType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#acc8f425f70fa557c11c1d740139d203a">_prepareEdge</a> (const int <a class="el" href="class_ordered_tree.html#af08cc116060aceed72652e875d96ff6a">edgeId</a>, const int from, const int to)</td></tr>
<tr class="memdesc:acc8f425f70fa557c11c1d740139d203a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method for inserting new edges.  <a href="#acc8f425f70fa557c11c1d740139d203a">More...</a><br /></td></tr>
<tr class="separator:acc8f425f70fa557c11c1d740139d203a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa524e3db76485fe4d20f6a31ede061a9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ordered_tree.html#aa524e3db76485fe4d20f6a31ede061a9">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt; &amp;tree)</td></tr>
<tr class="separator:aa524e3db76485fe4d20f6a31ede061a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename NodeType, typename EdgeType&gt;<br />
class OrderedTree&lt; NodeType, EdgeType &gt;</h3>

<p>Ordered tree data structure. </p>
<p>Holds an ordered tree</p>
<p>The tree is implemented as an adjacency array (See section 8.2 of <a href="http://people.mpi-inf.mpg.de/~mehlhorn/ftp/Toolbox/GraphRep.pdf">http://people.mpi-inf.mpg.de/~mehlhorn/ftp/Toolbox/GraphRep.pdf</a>)</p>
<p>You can define your own node and edge types, e.g. add labels to the nodes or values to the edges if you wish </p>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00037">37</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a9e706c8a83af2371285fd9c26fc061c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef EdgeType <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::<a class="el" href="class_ordered_tree.html#a9e706c8a83af2371285fd9c26fc061c9">edgeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of the edges used in this tree </p>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00042">42</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a00fd2d8abe3d806359f64418f554b292"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef NodeType <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::<a class="el" href="class_ordered_tree.html#a00fd2d8abe3d806359f64418f554b292">nodeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the node type used in this tree </p>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00040">40</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2d87bce2fd7297372d8eeaeaf58c99db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::<a class="el" href="class_ordered_tree.html">OrderedTree</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>m</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00044">44</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a40ba3358b30a489b54baf3296a0b7464"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::<a class="el" href="class_ordered_tree.html">OrderedTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00048">48</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="acc8f425f70fa557c11c1d740139d203a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EdgeType* <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::_prepareEdge </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>edgeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method for inserting new edges. </p>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00613">613</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a20d29122eb44dbe6b7f000d48f502703"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EdgeType* <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::addEdge </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>extraSpace</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add an edge to the tree </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>tail (source) node ID </td></tr>
    <tr><td class="paramname">to</td><td>head (destination) node ID </td></tr>
    <tr><td class="paramname">extraSpace</td><td>extra space to allocate for more outgoing edges of 'from' if more edges need to be allocated </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00130">130</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7963d8d12b4fb649977d083c049be9f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::addNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a node to the tree </p><dl class="section return"><dt>Returns</dt><dd>the new node's ID </dd></dl>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00105">105</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9d8fe28f1efab626e18370a1ac4e793a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::addNodes </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add multiple nodes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of nodes to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID of the first node added </dd></dl>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00118">118</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a56356437f508f5cff5bb5447f0539f90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::avgDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the average depth of the nodes in the tree. Uses <a class="el" href="class_ordered_tree.html#a7633cfabb942e9c6dd3f95a6533f1c07">foldLeftPostOrder()</a> and worth looking at as slightly more complex example for a fold </p>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00579">579</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="af283a4e3e05aa60a6ffa74efcdfab76c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::checkConsistency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a few consistency checks. NOP if NDEBUG is set </p>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00400">400</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3caa558a929a55e87e3c614d0707661c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00587">587</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a912ed15169fea16a72df1295f86eb2fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::compact </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compress the edge vector, removing gaps </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>whether to print some debug information </td></tr>
    <tr><td class="paramname">factor</td><td>how many times the number of its outgoing edges a node's edge space shall be allocated. If you set this to 2, for example, space for another edge will be reserved for each edge that there is, so that inserting an edge does not cause moving or reallocation. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00418">418</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad34b42496a697f8d9b25e2a28e56f172"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::compactNode </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nodeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00461">461</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="af08cc116060aceed72652e875d96ff6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::edgeId </td>
          <td>(</td>
          <td class="paramtype">const EdgeType *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get edge ID from pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge</td><td>an edge pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the edge's ID (index in the edge vector) </dd></dl>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00099">99</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5b1f92336e213a365dcce5aaa9bde4bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EdgeType* <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::firstEdge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pointer to the dummy edge </p>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00057">57</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a14c98c73a9f80543ebcbc78dd0a0858f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EdgeType* <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::firstEdge </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to a node's first edge. Does not check whether the node actually has outgoing edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>a node ID (index in the node vector) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to u's first outgoing edge </dd></dl>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00063">63</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a505076774887ba7391c2d3295c0c74c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EdgeType* <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::firstEdge </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const pointer to a node's first edge. Does not check whether the node actually has outgoing edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>a node ID (index in the node vector) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const pointer to u's first outgoing edge </dd></dl>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00069">69</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7633cfabb942e9c6dd3f95a6533f1c07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename Fold , typename Callback &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::foldLeftPostOrder </td>
          <td>(</td>
          <td class="paramtype">const Callback &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Fold &amp;&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>initial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a left fold over each node's children in post-order </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>a callback to be called for each node with the result of the last fold operation </td></tr>
    <tr><td class="paramname">fold</td><td>the fold function. Parameters: previous value, current value </td></tr>
    <tr><td class="paramname">initial</td><td>inital value for the first folding </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00553">553</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a68b9a851ac3450550c512ea75ea2ff62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::height </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the height of the tree (i.e., the maximum depth of a node). Uses <a class="el" href="class_ordered_tree.html#a7633cfabb942e9c6dd3f95a6533f1c07">foldLeftPostOrder()</a> and worth looking at as a simple example of a fold </p>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00571">571</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a209920ce1aafd5cf5c0e2011c90d85f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::initialise </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialise the tree </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number of nodes to reserve space for </td></tr>
    <tr><td class="paramname">m</td><td>number of edges to reserve space for </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00595">595</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4a7d966f7e234de6bf950e21b0878b0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::inplaceCompact </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do an inplace compaction of each node's vertices This is faster than rebuilding compaction. </p>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00483">483</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3d892bca85235b29ff2c6ce1ec5596c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::inplaceCompact </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>dirty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do an inplace compaction of only the dirty vertices This is faster than rebuilding compaction. </p>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00515">515</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="aca0a4924cb945b7b376b3a5cc58d98a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<div class="memtemplate">
template&lt;typename LabelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::isEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LabelType &amp;&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LabelType &amp;&#160;</td>
          <td class="paramname"><em>otherLabels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check whether this tree is equal to another tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other tree </td></tr>
    <tr><td class="paramname">labels</td><td>the labels for this tree. Label type is kept very general deliberately </td></tr>
    <tr><td class="paramname">otherLabels</td><td>the other tree's labels </td></tr>
    <tr><td class="paramname">verbose</td><td>whether to print an error traceback if the trees are not equal </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00313">313</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab70116d7ed7b45575d67054cb9b849b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::killNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00182">182</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab82a5cc65f5748cd93881d3976f40c6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EdgeType* <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::lastEdge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pointer to the last edge </p>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00074">74</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="aec1ab88ae092a8b2cf145a5ba57e4971"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EdgeType* <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::lastEdge </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to a node's last edge. Does not check wether the node actually has outgoing edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>a node ID (index in the node vector) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to u's last outgoing edge </dd></dl>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00080">80</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7ee1e8524bf710357b6f7d68fa64dcd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EdgeType* <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::lastEdge </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const ointer to a node's last edge. Does not check wether the node actually has outgoing edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>a node ID (index in the node vector) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const pointer to u's last outgoing edge </dd></dl>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00086">86</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a55db4b702c12893c28a7f73b50ee768f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::mergeChain </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>middleId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_common_8h.html#a97009d0c192b99b1a98c91001b6bb932">MergeType</a> &amp;&#160;</td>
          <td class="paramname"><em>mergeType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merge two chained edges like this: a -&gt; b -&gt; c will become a -&gt; b, where b and c are the only children of their parents. Any potential children of c will be attached to b. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">middleId</td><td>the middle node's ID in this merge (b in the example) </td></tr>
    <tr><td class="paramname">mergeType</td><td>will be set to the type of the merge performed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00279">279</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a23287252e8acca79a59ee7453abca69a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::mergeSiblings </td>
          <td>(</td>
          <td class="paramtype">const EdgeType *&#160;</td>
          <td class="paramname"><em>leftEdge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EdgeType *&#160;</td>
          <td class="paramname"><em>rightEdge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>newNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_common_8h.html#a97009d0c192b99b1a98c91001b6bb932">MergeType</a> &amp;&#160;</td>
          <td class="paramname"><em>mergeType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merge two descendants of the same node (i.e., siblings) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leftEdge</td><td>pointer to the edge leading to the left child </td></tr>
    <tr><td class="paramname">rightEdge</td><td>pointer to the edge leading to the right edge </td></tr>
    <tr><td class="paramname">newNode</td><td>will hold the ID of the merged node after this function returns </td></tr>
    <tr><td class="paramname">mergeType</td><td>will hold the type of the merge that was done after this returns </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00242">242</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a87b7882fe155507f941a32691d63fb89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::nodeId </td>
          <td>(</td>
          <td class="paramtype">const NodeType *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get node ID from pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>a node pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node's ID (index in the node vector) </dd></dl>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00093">93</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a43a8a0a7a547f33ada52e4d4d86328fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<div class="memtemplate">
template&lt;typename LabelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::nodesEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LabelType &amp;&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LabelType &amp;&#160;</td>
          <td class="paramname"><em>otherLabels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>otherNodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursive node comparison helper function used by <a class="el" href="class_ordered_tree.html#aca0a4924cb945b7b376b3a5cc58d98a9">isEqual()</a>. You should not need to use this directly. </p>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00322">322</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa61a2fbe7bec02c6257708d8f1134dec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::removeEdge </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>compact</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove an edge from the tree </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the edge's tail (source) node </td></tr>
    <tr><td class="paramname">edge</td><td>the edge's ID </td></tr>
    <tr><td class="paramname">compact</td><td>whether to consolidate 'from's outgoing edges </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00193">193</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="addf4aebe1125902df0a748f29eaba990"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::removeEdgeTo </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>compact</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove an edge between to nodes from the tree. Finds and removes the <em>first</em> edge from 'from' to 'to' </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>tail (source) node ID </td></tr>
    <tr><td class="paramname">to</td><td>head (destination) node ID </td></tr>
    <tr><td class="paramname">compact</td><td>wether to consolidate 'from's outgoing edges after removal </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00226">226</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a29695aaf8b1705665b786b6d10e06d24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::shortString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A rather compact representation of the tree as a string. Comprises nodes with children or a parent, and valid edges. Format: "  ID/(node or edge)" </p>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00357">357</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="aff0b8ba32873925ccc8dbb319f6fbf45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::summary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A one-line summary of the tree. </p>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00348">348</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="aee7a54309a9226726cdbadb4d7c201f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String representation of the tree, including all nodes and edges. </p>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00373">373</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a73ba00857ecf979a8e64226722579a98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename Fold , typename Callback &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::traverseFoldLeftPostOrder </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Callback &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Fold &amp;&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>initial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This does the work for <a class="el" href="class_ordered_tree.html#a7633cfabb942e9c6dd3f95a6533f1c07">foldLeftPostOrder()</a> and should not be used directly. </p>

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00559">559</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="aa524e3db76485fe4d20f6a31ede061a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00386">386</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a31cee9c6807d3f23acc2df9776e419ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::_firstFreeEdge</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00628">628</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a95203be7b453854a72f62df96ad45f2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::_firstFreeNode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00627">627</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8faf8ec27c5ad1c8289bc1203ee89fba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::_numEdges</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00630">630</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae8cec5b4d74adf59b17530e7dfe9a7cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::_numNodes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00629">629</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a76d83eedb11688aeac05e4f5b8070d15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;EdgeType&gt; <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::edges</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00626">626</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a269149ab46051dbd0d5cf8325ed1fcb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType, typename EdgeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;NodeType&gt; <a class="el" href="class_ordered_tree.html">OrderedTree</a>&lt; NodeType, EdgeType &gt;::nodes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ordered_tree_8h_source.html#l00625">625</a> of file <a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ordered_tree_8h_source.html">OrderedTree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 23 2015 18:13:59 for Tree Compression with Top Trees Revisited by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
